I want to create a small project with JavaScript (not TS for a change!)
I want that app to feature... functionality that highlights common JS needs / showcases that I know the fundamentals of JavaScript
I will use Vanilla tools for this application: HTML, CSS (might add a framework later, depending), and JSS
This app may or may not have a backend, but I'm leaning on keeping it simple
I will need to define what principals of JavaScript I want to demonstrate
I will use the JS Knowledge map to define what I intend to feature
I will restrict what I intend to feature so the project doesn't get completely out of hand lol

FEATURES:
Arrays

    .. (spread)
    .at()
    .every()
    .filter()
    .find()
    .forEach()
    .includes()
    .join()
    .length
    .map()
    .push()
    .reduce()
    .some()
    .splice()
    ?. (optional chaining)
    Arrays of objects
    [] (get item)
    destructuring

Classes

    Classes
    Getters
    Inheritance
            Class vs Function
            Private class fields
            Public class fields
            inheritance
            prototypal inheritance
            prototype chain
            super()
    Instance methods
    Instance variables
    Setters
    Static methods

DOM

    Events
            Change
            DOMContentLoaded
            Event details
            Focus/blur
            Keydown/keyup
            Scroll
            Submit
            element.addEventListener()
            element.removeEventListener()
            event.currentTarget
            event.preventDefault()
    HTML Element
            .classList.add()
            .classList.contains()
            .classList.remove()
            .classList.replace()
            .classList.toggle()
            .dataset
            .getAttribute()
            .innerHTML
            .insertAdjacentHTML()
            .parentElement
            .remove()
            .removeAttribute()
            .setAttribute()
            .style
            .textContent
            .value
            HTMLElement
            document.appendChild()
            document.createElement()
    Selection
            NodeList
            NodeList to Array
            document
            document.body
            document.documentElement
            document.getElementById()
            document.querySelector()
            document.querySelectorAll()
            element.closest()

Functions

    => (arrow functions)
    ?. (optional chaining)
    Asynchronous callbacks
    Callback pattern
    Closures
    Hoisting
    Lexical scope
    Passing functions
    basic functions
    default parameters
    implicit return

Misc

    Deep equal
    EcmaScript
    Event loop
    IIFE
    Immutability
    Window

Modules

    ES Modules
    Importing from libraries
    Module bundlers
    Package managers
    Parcel
    Vite
    Webpack
    default export
    import
    import() (dynamic imports)
    named export
    npm
    package.json
    script type="module"
    yarn

Number

    .toString()
    Division remainder (%)
    NaN
    Number.parseInt()

Objects

    ... (spread)
    ?. (optional chaining)
    ?? (nullish coalescing)
    Advanced control flow
    Object.entries()
    Object.keys()
    Object.values()
    destructuring
    dynamic properties
    object shorthand
    property access

Promises

    .catch()
    .finally()
    .then()
    Promise.reject()
    Promise.resolve()
    Promises
    async function
    async/await
    await keyword
    new Promise()
    states

Strings

    .at()
    .endsWith()
    .includes()
    .length
    .replace()
    .replaceAll()
    .split()
    .startsWith()
    .substring()
    .toLowerCase()
    .toUpperCase()
    .trim()
    Concatenation
    Template strings
    [] (character access)

Syntax

    Exceptions
    Semi-colons
    for (loops)
    for...in
    for...of
    if
    try...catch
    try...catch...finally

Variables

    ?? (nullish coalescing)
    Hoisting
    Temporal Dead Zone
    const
    let
    var (legacy)

fetch API

    DELETE
    Error handling
    Fetch Wrapper
    GET
    JSON.parse()
    JSON.stringify()
    POST
    PUT
    Response status codes
    Response.json()
    fetch()

I have created a git repo:

                git init 
                git add .
                git config --global user.email "rohr.olasz@gmail.com"
                git commit -m "initial commit"
                git remote add origin https://github.com/SJROHRXD/JSFeatureApp.git
                git push origin master

I will follow the In Plain English methodology in regards to application structure:

In Latin, redux (from the verb reducere, meaning "to lead back") can mean "brought back" or "bringing back."

Before we start
If I were to name the single most important thing you need to know in order to be effective with Vanilla, it's this:

Take advantage of the platform

This is from the Vanilla Redux Manifesto that we (try to) abide by in the front-end engineering team at Coin Metrics. (Btw, it's this redux, not the other one.) In short, if there's something the platform can do for you, understand what it does and take full advantage of it. Do not reinvent the wheel just because you don't like how the platform does it or what it looks like.

The files #
Let me get this out of the way: you do not need a build tool for this setup. Ideally, you just want to be able to open the index.html file and start working. While this sounds reasonably easy, we will nevertheless cover some details here that are probably not quite obvious to those that are just getting started with Vanilla (or maybe, like me, have done this for years in the past but completely lost the touch).

The bare minimum you need is a folder to house your files, index.html, index.js and index.css. (You can name CSS and JavaScript files anything you want, but the HTML file is usually named index.html because that's what the HTTP server will look for when you go to the root path of your application URL.)

Some developers like to have web servers that automatically reload parts of the application based on what's changed in the code. I find that this has not been reliable for me, and the cost of using these tools is comparatively high (I don't need any additional tooling to open a file in the browser, for example). Many editors will even let you get similar functionality for free if you are working with plain HTML/JavaScript/CSS, which, to me, feels like a better deal.

Keep in mind that the basic theme of the vanilla approach is not performance or reduction in bundle size or anything like that. People are happy with React's performance, so performance is clearly not a very desirable characteristic. Our goal is to not introduce complexity that isn't strictly needed by our application. This starts with any tooling around the project and continues with the code.